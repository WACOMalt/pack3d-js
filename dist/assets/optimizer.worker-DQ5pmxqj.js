(function(){"use strict";class w{constructor(){this.gravity=9.81}checkCollision(t,i){const s=t.x-t.width/2,r=t.x+t.width/2,h=t.y-t.height/2,e=t.y+t.height/2,n=t.z-t.depth/2,a=t.z+t.depth/2,c=i.x-i.width/2,o=i.x+i.width/2,d=i.y-i.height/2,p=i.y+i.height/2,l=i.z-i.depth/2,f=i.z+i.depth/2,u=r>c&&s<o,m=e>d&&h<p,M=a>l&&n<f;return u&&m&&M}checkCollisionWithList(t,i){for(const s of i)if(this.checkCollision(t,s))return!0;return!1}isWithinContainer(t,i){const s=t.x-t.width/2,r=t.x+t.width/2,h=t.y-t.height/2,e=t.y+t.height/2,n=t.z-t.depth/2,a=t.z+t.depth/2,c=-i.width/2,o=i.width/2,d=0,p=i.height,l=-i.depth/2,f=i.depth/2;return s>=c&&r<=o&&h>=d&&e<=p&&n>=l&&a<=f}dropBox(t,i,s){let h=t.y;const e=t.height/2;for(;h>e;){const n={...t,y:h};let a=!1;for(const c of i)if(this.checkCollision(n,c)){a=!0;break}if(a)return h+.1;h-=.5}return e+.001}calculateStability(t,i,s){const r=t.x-t.width/2,h=t.x+t.width/2,e=t.z-t.depth/2,n=t.z+t.depth/2,a=t.y-t.height/2;if(Math.abs(a)<.1)return 1;const c=t.width*t.depth;let o=0;const d=.5;for(const l of i){const f=l.y+l.height/2;if(Math.abs(f-a)<d){const u=Math.max(r,l.x-l.width/2),m=Math.min(h,l.x+l.width/2),M=Math.max(e,l.z-l.depth/2),y=Math.min(n,l.z+l.depth/2);if(m>u&&y>M){const k=(m-u)*(y-M);o+=k}}}const p=Math.min(o/c,1);return p<.5?p*.5:p}isValidPlacement(t,i,s,r=.3){return!(!this.isWithinContainer(t,s)||this.checkCollisionWithList(t,i)||t.y-t.height/2>.1&&this.calculateStability(t,i,s)<r)}}class z{constructor(){this.physicsSolver=new w}optimize(t){const{boxes:i,constraints:s,maxAttempts:r}=t,h=performance.now();self.postMessage({type:"progress",message:"Initializing optimization...",progress:0});const e=this.findMinimumContainer(i,s);if(!e)return{success:!1,error:"Could not find valid packing"};const n=performance.now(),a=Math.round(n-h);return{success:!0,container:e.container,placedBoxes:e.placedBoxes,executionTime:a}}findMinimumContainer(t,i){const s=[];i.width===null&&s.push("width"),i.height===null&&s.push("height"),i.depth===null&&s.push("depth");const r=t.reduce((o,d)=>o+d.width*d.height*d.depth,0),h={width:Math.max(...t.map(o=>o.width)),height:Math.max(...t.map(o=>o.height)),depth:Math.max(...t.map(o=>o.depth))};let e={width:i.width||h.width,height:i.height||h.height,depth:i.depth||h.depth};const n=(i.width||1)*(i.height||1)*(i.depth||1);if(s.length>0){const o=r*1.5,d=Math.pow(o/n,1/s.length);s.forEach(p=>{e[p]=Math.max(h[p],Math.ceil(d))})}let a=0;for(const o of s)a++,self.postMessage({type:"progress",message:`Optimizing dimension: ${o}...`,progress:10+Math.floor(a/s.length*40)}),e[o]=this.binarySearchDimension(t,e,o,h[o],Math.max(e[o]*3,h[o]*5));self.postMessage({type:"progress",message:"Finalizing packing...",progress:60});let c=this.attemptPacking(t,e,0);if(c.length<t.length&&s.length>0){let o=0;const d=20;for(;c.length<t.length&&o<d;)o++,self.postMessage({type:"progress",message:`Expanding container (Attempt ${o}/${d})...`,progress:60+Math.floor(o/d*30)}),s.forEach(p=>{e[p]=Math.ceil(e[p]*1.1),e[p]===e[p]/1.1&&(e[p]+=1)}),c=this.attemptPacking(t,e,0)}return self.postMessage({type:"progress",message:"Done!",progress:100}),{container:e,placedBoxes:c}}binarySearchDimension(t,i,s,r,h){let n=r,a=h,c=a;for(;a-n>5;){const o=Math.floor((n+a)/2),d={...i,[s]:o};let p=!1;for(let l=0;l<3;l++)if(this.attemptPacking(t,d,l).length===t.length){p=!0;break}p?(c=o,a=o):n=o+1}return c}attemptPacking(t,i,s){const r=[...t];this.shuffleArray(r,s),r.sort((e,n)=>{const a=e.width*e.height*e.depth;return n.width*n.height*n.depth-a});const h=[];for(const e of r){const n=this.findPlacement(e,h,i,s);n&&h.push(n)}return h}findPlacement(t,i,s,r){const h=this.generateCandidatePositions(t,i,s);this.shuffleArray(h,r+t.instanceId);for(const e of h){const n={...t,x:e.x,y:e.y,z:e.z};if(e.y>t.height&&!e.skipGravity&&(n.y=this.physicsSolver.dropBox(n,i,s)),this.physicsSolver.isValidPlacement(n,i,s,.2))return n}return null}generateCandidatePositions(t,i,s){const r=[];r.push({x:-s.width/2+t.width/2,y:t.height/2,z:-s.depth/2+t.depth/2});for(const e of i){r.push({x:e.x,y:e.y+e.height/2+t.height/2,z:e.z,skipGravity:!0});const n=e.y+e.height/2+t.height/2;r.push({x:e.x+(e.width-t.width)/4,y:n,z:e.z,skipGravity:!0}),r.push({x:e.x-(e.width-t.width)/4,y:n,z:e.z,skipGravity:!0}),r.push({x:e.x,y:n,z:e.z+(e.depth-t.depth)/4,skipGravity:!0}),r.push({x:e.x,y:n,z:e.z-(e.depth-t.depth)/4,skipGravity:!0}),r.push({x:e.x+e.width/2+t.width/2,y:e.y,z:e.z}),r.push({x:e.x,y:e.y,z:e.z+e.depth/2+t.depth/2});const a=[{dx:1,dz:1},{dx:-1,dz:1},{dx:1,dz:-1},{dx:-1,dz:-1}];for(const c of a)r.push({x:e.x+c.dx*(e.width/2+t.width/2),y:e.y,z:e.z+c.dz*(e.depth/2+t.depth/2)})}const h=5;for(let e=0;e<h;e++)for(let n=0;n<h;n++)r.push({x:-s.width/2+(e+.5)*(s.width/h),y:t.height/2,z:-s.depth/2+(n+.5)*(s.depth/h)});return r}shuffleArray(t,i){let s=t.length,r,h;const e=()=>{const n=Math.sin(i++)*1e4;return n-Math.floor(n)};for(;s;)h=Math.floor(e()*s--),r=t[s],t[s]=t[h],t[h]=r;return t}}const v=new z;self.onmessage=g=>{if(g.data.type==="start")try{const t=v.optimize(g.data.params);self.postMessage({type:"complete",result:t})}catch(t){self.postMessage({type:"error",error:t.message})}}})();
